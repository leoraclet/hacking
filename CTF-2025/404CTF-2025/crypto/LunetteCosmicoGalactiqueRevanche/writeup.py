from Crypto.Util.number import isPrime, long_to_bytes
from sage.all import *
from time import time


def branch_and_prune(n, a, b, d0, d1):
    solutions = [(1, 1)]
    for bit_pos in range(2, 2049):
        next_solutions = []
        modulus = 2**bit_pos
        added = 2 ** (bit_pos - 1)
        target_n = n % modulus
        for solution in solutions:
            pqs = [
                (solution[0], solution[1]),
                (solution[0], solution[1] + added),
                (solution[0] + added, solution[1]),
                (solution[0] + added, solution[1] + added),
            ]
            for i in range(4):
                p, q = pqs[i]
                if ((p - d0) * a + b) % modulus == (q - d1) % modulus and (
                    p * q
                ) % modulus == target_n:
                    next_solutions.append(pqs[i])
        solutions = next_solutions.copy()
        if solutions == []:
            break
    for p, q in solutions:
        if p * q == n and isPrime(p) and isPrime(q):
            print(f"Found primes: {p}, {q}")
            return p, q
    return None


start = time()

p0 = 288657040481406434513937980300367602280601009198531526413245719864368237889782636832529822139416041456487243376791604484506079960106376898143411762871023937310891000658768880882642508533402596243267327002179700130659665170762984265810921692048761329067936370304693627023685193941932513040627654389394748026471362471886995467651654587048646851539372401910079718793904417209603218897845732573676845459323525060492576996396084310600973856305943096568181699166306840588340442339387458408393237996095585121189350270257874458848656762302932362821433090868409761165342541851759884986566409699976762029182
p1 = 745138793974871081360252190314514224883210428784010294632293153535343730718035742203058066166232488027550958447883440253745408300950767396458474719496711355669804086026225674564918569788603642186902458211130380965447297023693729857956781684834686551985470466465433910919443479720322525451008654827021383508832220605504802559266495732475743364039915945448411762029324766442776065719338938212781534411288177855341349597494331369344152526272026132253979745607967121261055707974542904825659587492135339357296697871635955211121904407378504747553304492035435083557357080856260476723881466837315575642164
p2 = 422997789274108342282841712737868521568986963816718302425065248326599462780145732668354127651679440801602450324869011656678276678140590891780905598002756376549986768016930619035464477952596772677060668194196577097845112475591576910596885801779695065673958394730245950883968169655923567767518732884995992938122093468595910569543352018340088190245924882877500820790359834912937801563656673458431806726944350967895468194380948065849843856321201875379825324845575018968111010254502233155523279148409187782723073600923856601572101240713416182535467316924967295678450629475777336216792992194704431103539
ct = "4b6c5bd6be309387011fa930c8952f4b19d039e420abb26fd4337fd3482231446c86097c64a087acaf62b932eed6e2adecaa3c6adbbabedfe33bcaa94b616719192d4f8ad8373341848c1c05448ddb61ee23983ca54e780d95e582625419c1d8129514f71e89f2b00d55edca8e455f5031a3e798e264e0178248fdcb32274d0edf22d3262b60498c2c250c446d1fb0b9f162973af6824045a6dc46bf5613cb1098d8f4382b4125cce563e26e8ac38c8c42863734e7069db0e343db169f906610eb3144f06eeddbcc50f0e0e3a5abfc2b29a9c13497b8a73b6b0f21f6eb529fbb09794f9dd16a54b508b8367e89c2169742ff7e92b8715b08b1d3dfd42af9171651a751a33dc4fa5781a538ed7b9ba381cef79f79bc60980bd172c76143e604f6d0505896b82f95c97a463d05d165b7edefa42c9a874eae743a54ce84d0cc04685e8bed5cfbfda35e51a51693d75875abd82f4a358fd4440807fbb3095eddb83e51ef6e9fd16cb527cb08519318f3166b275e5a744fd28ee40946cafc2dddcdd07342ea45c560700017ebc6e780be8a08c58478d78bbaf12b09e9d57602377526f9695cca57e9ffd6ef45a339752b39ec1bad97a2a1c5dffc50e0a7649e3850b425b6e4ba5b65d57ec465b811fe4cc3ae9cfb0acf4fb36cf495d393920173a1fdc9858a5e160d25ca36d3e96c64779383741c15f6e193ad4bf201233e141cf71-9e9d51282fb895d9d9f82e718560379ee782f8ecc128d81740e9b15fe315eae37c2cedc388ef9a7c8a1325cddcc622a2dc5448612ba87bd38a5e970680c4ddf14084fc3ee9db0f0edd842dea2f5269963fc739c1b63fe051b587f6e5fe9bdf43e61e75fecc70fe94f4c149e09d40513938b4dd449d9969d48c62efeede89f706118bfdb859d5c7fad5203f76718a550c6e6287d4f21aed9e97db2fc8a838a55516c3166a972d09b63121e41b6229b5ebab85bf823e4edc68202752549797be20a35c8c0483183fa84ba40a387c0530344d63b235e1585d9ca81b5d5d5e6a161a53160046b87ca9c9412179cdcd320218a95ba9e910013eefac89b55d3ef222d1b80742d99d7831e370444f25ab5cd4f1accbeac0f27e0dc9edf172795831bcdce9cfd53636fb5acbe2a9febdec5be5c20bab11236a2e64bff32d41534886d91ff5da79d711ea3fc105f52644c9ee1d3f2016624888586ec219f61b360cbd22c8cb2d1bc5681f27ff95aa004c5b59b96892ed1dea942b2600dd3bedd1b88544950d356f0b3c7497a87541b4caf630a1599f4f27f4d64febd069ff8bcc13f142809cb10b83e06705d019f50558a4e57a877228d08175792b09fee9c6fbbe3e720ca576e37b576c8ae5ea4559f2e736033a2e1c04ce4ff58968f80e83f1c79fca42adb08496e6d33c3086d17959b8bee651c9d9af2bec5af392732ef3559d08d9-bb4909b4ed6e9641553e466a67acdb60eb6afd4841f5d5ff715620e0ca235aa80401f7836271c31376e0e90b427e466d5a3e85fa6875f4ea58566ec242e4264af22031a441a8b046323d4ba8e8bdcba46e322f539a8fcb409b5c6d89f54d91609183f7dc216c70940b6bd80523bd1023a1bd00d64d1f39398e69f0570275e9fc834a92fd2ab84a9a13bdc833c2b59f09a05ca0c7e42c0d9c43a3a81c59f858804f8bc01fabea3efc74807be45be37f78c8dc09d5320d052160a9f6a683fb2c2492ca12795ef3605eb97f8c8159e066d1e1c9c3504dd78bf074fac62087c832fc11f0e62b0ca4473e515a7ca4056b8e28cfce78087cfe79c362a5e8c06529be4ac35cc1a35b6b10cdf2a04af3c24db0a298f98ed14863a3b3c98f0fbcc54736b2aebddc960f6f16afbb3fa668c010223db7854c663bf35e8cf0d4ffdd9f461b6b24092bab01b5ee5077fb98785b8eae4c27cdd756e29ffdd8effe26003ccdbb29c84ef452686c2e789a69255443b7894335273350f979a852aa8b11cba7be83c386cd514e8b0582d889ba218f482294f24c5444d96b23a43ca2dd32da3cbafb23034fb5553b3049d24851cfc996a6dc14318d6e48367e35afa465efc1cecb116fdd7f2bd94badea77eeb969301014f68cadeb894e70af2a26aae8ada3599ebb1d7921fab4f206bb9cc2f6065eb1682bbd1b520d1504c68d32ded3888537cf6b-3c15002fc3a800a77f794ab0bc540fa3d2c032158da5828ab9f338ec5028672bbddc03bf051c28ee333e7f0839b836f893bbfaa25f632e732975d0379f404598f0e47ce631b0d2077d8fb1452e5d223f7e280d2e8c406becc16cdb3b91edf6b804bc78bda29d2c71dd67bee439e341a428ce1540960fc28ad7c2f53aa273e2c564576ee2af68e0ec23c143e155c79779c708b6c9c2bba8aa26ca22499ceb1de9400a6b8572cde57a070194de7140ff9a2d6c127f94388bb6e5da39b6aca1068414f49e626d1e144dff2ea650e5928907c4c3341d1574f4159ed0c195c268b589eb09b11aaa2a0e0255672aed1670e49fa2366a2ab41e9f753e3b8b3095af673347be3c84a28a7b561ffb16a861f481ca7926641c20bf6324f9e1b95298a9df8dd332a0d27db7f561bf651214b14ae220493f25988d17e98a6cac563de4d5f44e29568ea761da44b574d9bae0c8a6342c4fb7264e38f77ecd8256c010e3fc9017f5e5f49282395028d0fe93b951af0dee3303ec71e9dbb17364a384bceabb0b0a120c89177511d92a52bae52f497adf9d6f6221021cc448c426850daccf81b5d7a37882622554ad61f95298604d6a03dedb7de10c37f7d1a8257d943622b5e57f6f8fac8a520b060a23bdb1ca6ec958e361d950e92e69c91bd667fd40949537628c732e53c0da09f20df55b0194f6d477a9ec5f1597994aba33e30a81f2150e"
n1, c1, n2, c2 = [int(x, 16) for x in ct.split("-")]

# p0 = s + d0
# p1 = a * s + b + d1
# p2 = a^2 * s + a * b + b + d2
M = 2**2048
M2 = 2**64
ps = [p0, p1, p2]
L = matrix(
    ZZ,
    [
        [p0 * M2, p1 * M2, 1],
        [p1 * M2, p2 * M2, 0],
        [M, 0, 0],
        [0, M, 0],
    ],
)
W = diagonal_matrix(ZZ, [1, 1, 512], sparse=False)
L = (L * W).LLL() / W
# target = [a * d0 - b - d1, a * d1 - b - d2, a]
for row in L:
    row = [abs(int(x)) for x in row]
    if not isPrime(row[-1]):
        continue
    if row[-1].bit_length() != 512:
        continue
    # print(f'{row = }')
    a = row[-1]
    print(f"{a = }")
    break
v0, v1 = row[:2]
T = matrix(ZZ, [[1, 0, a, 0], [0, 1, 1, a], [0, 0, -v0, -v1]])
TW = diagonal_matrix(ZZ, [2**447, 2**447, 2**0, 2**0], sparse=False)
T = (T * TW).LLL() / TW
for row in T:
    row = [abs(int(x)) for x in row]
    d0, d1 = row[:2]
    try:
        for m0 in range(-8, 9):
            for m1 in range(-8, 9):
                b = v0 - a * (d0 + m0) + (d1 + m1)
                if isPrime(b) and b.bit_length() == 512:
                    print(f"{b = }\n{d0 = }\n{d1 = }")
                    raise ValueError("Found b")
    except ValueError:
        break

# a = 8023445618414020895095530939641283362116293862581462198685119785296130647919372499991467553851514341805110974903407317918984509993209302966282676499023031
# b = 7149671536391230839690952809612744302613290442060585402759429950086435343441143609037905738021476159621778718746115241347385947194530355241672082688348733

# n1 = p0 * p1 = (s + d0) * (a * s + b + d1)
# n2 = p2 * p3 = (a^2 * s + a * b + b + d2) * (a^2 * s + a * b + b + d3)

P = PolynomialRing(Zmod(M), names="s, e0, e1, e2, e3")
s, e0, e1, e2, e3 = P.gens()
p00 = s + e0
p01 = a * s + b + e1
p10 = a**2 * s + a * b + b + e2
p11 = a**3 * s + a**2 * b + a * b + b + e3

f0 = p00 * p01 - n1
f1 = p10 * p11 - n2

g = f0.sylvester_matrix(f1, s).det()
# print(f'{g = }')
bounds = [2**2048] + [2**12] * 4
mat, mons = Sequence([g]).coefficients_monomials()
print(mat.dimensions(), len(mons))
print(f"{mons = }")
# mons = mons.change_ring(ZZ)
vals = [int(x(*bounds)) for x in mons]
scale = [max(vals) // x for x in vals]

L = block_matrix(ZZ, [[identity_matrix(len(mons)), mat.T], [0, M]])
W = diagonal_matrix(ZZ, scale + [2**1000], sparse=False)
L = (L * W).LLL() / W
for row in L:
    if row[-1] != 0:
        continue
    if row[-2] not in [-1, 1]:
        continue
    if row[-2] == -1:
        row = -row
    print([int(x).bit_length() for x in row])
    print(f"{row = }")
    es = row[-6:-2]
    print(f"{es = }")
    break
e0, e1, e2, e3 = [int(x) for x in es]
# print(f'{e0 = }\n{e1 = }\n{e2 = }\n{e3 = }')
# print(f'{n1 = }')
# print(f'{a = }\n{b = }')
p0, p1 = branch_and_prune(n1, a, b, e0, e1)
p2, p3 = branch_and_prune(n2, a, b, e2, e3)
d0 = pow(65537, -1, (p0 - 1) * (p1 - 1))
d1 = pow(65537, -1, (p2 - 1) * (p3 - 1))
m0 = pow(c1, d0, n1)
m1 = pow(c2, d1, n2)
print(long_to_bytes(m0) + long_to_bytes(m1))
print(f"Time taken: {time() - start} seconds")
